package claudecode

import (
	"context"
	"io"
	"os"
	"syscall"
	"time"
)

// tailReader implements an io.Reader that follows a file (tail -f).
// It blocks at EOF until more data is available or the context is canceled.
// If pid is > 0, it stops at EOF if the process is no longer running.
type tailReader struct {
	f   *os.File
	pid int
	ctx context.Context
}

func newTailReader(ctx context.Context, filename string, pid int) (*tailReader, error) {
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}

	// Seek to end if we are attaching? No, if we attach we might want recent history.
	// But `bufio.Scanner` will read everything from the start.
	// For "Attach", we probably want to seek to the end or near the end?
	// Actually, for "reattach", we want to catch up on what we missed.
	// So reading from start is safer, though it might replay old events.
	// Athena's event log handles deduplication via sequence/ID usually.
	// BUT `Process.Events()` emits everything.
	// If we replay old events, the `Spawner` will try to ingest them.
	// `pipeline.Ingest` should be idempotent if message IDs are stable.
	// `ParseEvent` parses JSON which might contain IDs.
	// If IDs are not in the JSON stream (generated by Spawner), we have a problem: duplicates.
	// The `claude` CLI output events usually contain IDs?
	// Let's check `ParseEvent` in `events.go`.

	return &tailReader{
		f:   f,
		pid: pid,
		ctx: ctx,
	}, nil
}

func (t *tailReader) Read(p []byte) (n int, err error) {
	for {
		if t.ctx.Err() != nil {
			return 0, io.EOF
		}

		n, err = t.f.Read(p)
		if n > 0 {
			return n, nil
		}
		if err != io.EOF {
			return 0, err
		}

		// EOF. Check if process is alive.
		if t.pid > 0 && !isProcessRunning(t.pid) {
			return 0, io.EOF
		}

		// Wait a bit
		select {
		case <-t.ctx.Done():
			return 0, io.EOF
		case <-time.After(250 * time.Millisecond):
			continue
		}
	}
}

func (t *tailReader) Close() error {
	return t.f.Close()
}

func isProcessRunning(pid int) bool {
	process, err := os.FindProcess(pid)
	if err != nil {
		return false
	}
	// On Unix, sending signal 0 checks existence
	err = process.Signal(syscall.Signal(0))
	return err == nil
}
